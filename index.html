<!doctype html>
<html lang="en">
<head>
	<title>Digital Universe</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body 
		{
			background-color: #191919;
			margin: 0px;
			overflow: hidden;
		}
	</style>
</head>
<body>
<!-- 	<div id="map" style="width: 400px; height: 300px; float: left; padding: 0;"></div>
	<div id="controls" style="">
		<form id="map_form">
			<input type="text" name="address" id="address" />
			<button type="submit" id="searchButton" >Search</button>
		</form>
	</div> -->
	
<!-- 	<div id="text" style="width: 500px; height: 120px; float: left; padding-top: 10px; z-index:0; border-style:solid; border-width:medium;"></div> -->
	<div id="pano" style="display:none"></div>
	<div id="message"></div>

	<script src="js/Three.js"></script>
	<script src="js/Detector.js"></script>
	<script src="js/Stats.js"></script>
	<script src="js/TrackballControls.js"></script>
	<script src="js/THREEx.KeyboardState.js"></script>
	<script src="js/THREEx.FullScreen.js"></script>
	<script src="js/THREEx.WindowResize.js"></script>
	<script src="js/jquery-1.9.1.min.js"></script>
	<script src="https://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false" type="text/javascript"></script> 
	<script src="js/three.min.js"></script>
	<script src="js/GSVPano.js"></script>

	<script>
	 /*
	 	Project by Yi Ning Huang
	 	hsnu20054@gmail.com
	 	for Parsons The New School for Design, Major Studio 2, with Melanie Crean. Spring 2013.
		
		code adopted from Lee Stemkoski's awesome Three.js "tutorials by example" (http://stemkoski.github.io/Three.js/)
		images: Black Marball (http://www.techfleece.com/2012/12/06/black-marble-an-incredible-look-at-our-planet-at-night/)
		Google Street Images animation created with Peter Nitsch's Hyperapse.js (http://hyperlapse.tllabs.io/)
	 */

	var container, scene, camera, renderer, controls, stats;
	var keyboard = new THREEx.KeyboardState();
	var clock = new THREE.Clock();

	var _renderer;
	var earthMesh, cloudsMesh, glitch;
	var sprite, geometry, bgParameters, color, size, materials = [];

	var angularSpeed = 0.005;
	var lastTime = 0;

	init();
	animate()
		
	function init() 
	{
		// SCENE
		scene = new THREE.Scene();
		scene.fog = new THREE.Fog( 0xffffff, 1, 1000000 );
		// CAMERA
		var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
		var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 100000000;
		camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
		scene.add(camera);
		camera.position.set(0,150,400);
		camera.lookAt(scene.position);	
		// RENDERER
		if ( Detector.webgl )
			renderer = new THREE.WebGLRenderer( {antialias:true} );
		else
			renderer = new THREE.CanvasRenderer(); 
		renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
		container = document.createElement( 'div' );
		document.body.appendChild( container );
		container.appendChild( renderer.domElement );
		// EVENTS
		THREEx.WindowResize(renderer, camera);
		THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });
		// CONTROLS
		controls = new THREE.TrackballControls( camera );
		// // STATS
		// stats = new Stats();
		// stats.domElement.style.position = 'absolute';
		// stats.domElement.style.bottom = '0px';
		// stats.domElement.style.zIndex = 100;
		// container.appendChild( stats.domElement );
		// LIGHT
		var directionalLight = new THREE.DirectionalLight(0xffffff);
		directionalLight.position.set(2, 1, 2).normalize();
		scene.add(directionalLight);
		// BACKGROUND STUFF
		geometry = new THREE.Geometry();
		sprite1 = THREE.ImageUtils.loadTexture( 'images/flake01.png' );
		sprite2 = THREE.ImageUtils.loadTexture( 'images/flake02.png' );
		sprite3 = THREE.ImageUtils.loadTexture( 'images/flake03.png' );
		sprite4 = THREE.ImageUtils.loadTexture( 'images/flake04.png' );
		sprite5 = THREE.ImageUtils.loadTexture( 'images/flake05.png' );

		for ( i = 0; i < 4000; i ++ ) {
			var vertex = new THREE.Vector3();
			vertex.x = Math.random() * 120000 - 60000;
			vertex.y = Math.random() * 120000 - 60000;
			vertex.z = Math.random() * 120000 - 60000;
			geometry.vertices.push( vertex );
		}

		bgParameters = [ [ [1, 0, 1], sprite2, Math.random() * 1000 ],
					   [ [1, 0, 1], sprite3, Math.random() * 500 ],
					   [ [1, 0, 1], sprite1, Math.random() * 800 ],
					   [ [1, 0, 1], sprite5, Math.random() * 800 ],
					   [ [1, 0, 1], sprite4, Math.random() * 1000 ],
					   ];
		
		for ( i = 0; i < bgParameters.length; i ++ ) {

			color  = bgParameters[i][0];
			sprite = bgParameters[i][1];
			size   = bgParameters[i][2];

			materials[i] = new THREE.ParticleBasicMaterial( { size: size, map: sprite, blending: THREE.AdditiveBlending, depthTest: false, transparent : true, opacity: Math.random() } );
			materials[i].color.setHSL( color[0], color[1], color[2] );

			particles = new THREE.ParticleSystem( geometry, materials[i] );

			particles.rotation.x = Math.random() * 6;
			particles.rotation.y = Math.random() * 6;
			particles.rotation.z = Math.random() * 6;

			scene.add( particles );

		}
		
		// // axes
		// var axes = new THREE.AxisHelper(100);
		// scene.add( axes );

		var earth = new THREE.ImageUtils.loadTexture( 'images/earth3.jpg', transparent = false );
		earthMesh = new THREE.Mesh( 
			new THREE.SphereGeometry( 2000, 60, 50 ), 
			new THREE.MeshLambertMaterial( { map: earth, side: THREE.DoubleSide, fog: false } ) 
		);
		earthMesh.position.set(-3000, 0, 0 );
		scene.add( earthMesh );

		var sphereGeom =  new THREE.SphereGeometry( 2000, 50, 50 ); // radius, segmentsWidth, segmentsHeight
		mirrorSphereCamera = new THREE.CubeCamera( 0.2, 10000, 512/7  );
		// mirrorCubeCamera.renderTarget.minFilter = THREE.LinearMipMapLinearFilter;
		scene.add( mirrorSphereCamera );
		var mirrorSphereMaterial = new THREE.MeshBasicMaterial( { envMap: mirrorSphereCamera.renderTarget } );
		mirrorSphere = new THREE.Mesh( sphereGeom, mirrorSphereMaterial );
		mirrorSphere.position.set(5000,0,0);
		mirrorSphereCamera.position = mirrorSphere.position;
		scene.add(mirrorSphere);

		var moon = new THREE.ImageUtils.loadTexture( 'images/moon.jpg', transparent = false );
		moonMesh = new THREE.Mesh( 
			new THREE.SphereGeometry( 500, 50, 50 ), 
			new THREE.MeshLambertMaterial( { map: moon, side: THREE.DoubleSide, fog: false } ) 
		);
		moonMesh.position.set(3000, 3000, -2000 );
		scene.add( moonMesh );

		var cageTexture = THREE.ImageUtils.loadTexture( 'images/milkyway.jpg' );
		var cageMaterial = new THREE.MeshLambertMaterial( { map: cageTexture, transparent: true, opacity: 0.5, side:THREE.DoubleSide } );
		var cage = new THREE.Mesh(  new THREE.SphereGeometry( 30000, 32, 32 ), cageMaterial );
		cage.position.set(0, 0, 0);
		scene.add( cage );

		var glitchTexture = THREE.ImageUtils.loadTexture( 'images/glitch6.png' );
		var glitchMaterial = new THREE.MeshLambertMaterial( { map: glitchTexture, transparent: true, opacity: 0.3, side:THREE.DoubleSide } );
		glitch = new THREE.Mesh(  new THREE.SphereGeometry( 2000, 50, 50 ), glitchMaterial );
		glitch.position.set(5000, 0, 0);
		scene.add( glitch );

		// var clouds = new THREE.ImageUtils.loadTexture( 'images/earth-clouds.png', transparent = true, opacity = 0.5);
		// cloudsMesh = new THREE.Mesh( 
		// 	new THREE.SphereGeometry( 100000, 50, 50 ), 
		// 	new THREE.MeshLambertMaterial( { map: clouds, side: THREE.FrontSide, transparent: true, opacity: 0.5} ) 
		// );
		// cloudsMesh.position.set(0, 0, 0 );
		// scene.add( cloudsMesh );
		
	}

	function animate() 
	{
	    requestAnimationFrame( animate );
		render();		
		update();
	}

	function update()
	{
		// if ( keyboard.pressed("z") ) 
		// { 
		// 	// do something
		// }
		var time = new Date().getTime();
		var timeDiff = time - lastTime;
		var angleChange = angularSpeed * timeDiff * 2 * Math.PI / 5000;
		earthMesh.rotation.y += angleChange;
		glitch.rotation.y += angleChange*1000;
		//cloudsMesh.rotation.y += angleChange;
		//cloudsMesh.rotation.x += angleChange/0.7;
		lastTime = time;
		controls.update();
		stats.update();
	}

	function render() 
	{
		var time = Date.now() * 0.000002;
		for ( i = 0; i < scene.children.length; i ++ ) {
			var object = scene.children[ i ];
			if ( object instanceof THREE.ParticleSystem ) {
				object.rotation.y = time * ( i < 4 ? i + 1 : - ( i + 1 ) );
			}
		}
		mirrorSphere.visible = false;
		mirrorSphereCamera.updateCubeMap( renderer, scene );
		mirrorSphere.visible = true;
		renderer.render( scene, camera );
	}

	</script>
	<script src="js/Hyperlapse.js"></script>

</body>
</html>
